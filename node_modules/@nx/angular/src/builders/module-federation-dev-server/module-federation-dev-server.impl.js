"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeModuleFederationDevServerBuilder = void 0;
const devkit_1 = require("@nx/devkit");
const ngcli_adapter_1 = require("nx/src/adapter/ngcli-adapter");
const webpack_dev_server_impl_1 = require("../webpack-dev-server/webpack-dev-server.impl");
const project_graph_1 = require("nx/src/project-graph/project-graph");
const executor_utils_1 = require("nx/src/command-line/run/executor-utils");
const module_federation_1 = require("../utilities/module-federation");
const fs_1 = require("fs");
const path_1 = require("path");
const module_federation_2 = require("@nx/webpack/src/utils/module-federation");
const child_process_1 = require("child_process");
const rxjs_1 = require("rxjs");
function executeModuleFederationDevServerBuilder(schema, context) {
    // Force Node to resolve to look for the nx binary that is inside node_modules
    const nxBin = require.resolve('nx/bin/nx');
    const { ...options } = schema;
    const projectGraph = (0, devkit_1.readCachedProjectGraph)();
    const { projects: workspaceProjects } = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph);
    const project = workspaceProjects[context.target.project];
    const staticFileServer = (0, rxjs_1.from)(Promise.resolve().then(() => require('@nx/web/src/executors/file-server/file-server.impl'))).pipe((0, rxjs_1.switchMap)((fileServerExecutor) => fileServerExecutor.default({
        port: options.port,
        host: options.host,
        ssl: options.ssl,
        buildTarget: options.browserTarget,
        parallel: false,
        spa: false,
        withDeps: false,
        cors: true,
    }, {
        projectGraph,
        root: context.workspaceRoot,
        target: projectGraph.nodes[context.target.project].data.targets[context.target.target],
        targetName: context.target.target,
        projectName: context.target.project,
        configurationName: context.target.configuration,
        cwd: context.currentDirectory,
        isVerbose: options.verbose,
        projectsConfigurations: (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph),
        nxJsonConfiguration: (0, devkit_1.readNxJson)(),
    })));
    const webpackDevServer = (0, webpack_dev_server_impl_1.executeWebpackDevServerBuilder)(options, context);
    const currExecutor = options.static ? staticFileServer : webpackDevServer;
    if (options.isInitialHost === false) {
        return currExecutor;
    }
    let pathToManifestFile = (0, path_1.join)(context.workspaceRoot, project.sourceRoot, 'assets/module-federation.manifest.json');
    if (options.pathToManifestFile) {
        const userPathToManifestFile = (0, path_1.join)(context.workspaceRoot, options.pathToManifestFile);
        if (!(0, fs_1.existsSync)(userPathToManifestFile)) {
            throw new Error(`The provided Module Federation manifest file path does not exist. Please check the file exists at "${userPathToManifestFile}".`);
        }
        else if ((0, path_1.extname)(options.pathToManifestFile) !== '.json') {
            throw new Error(`The Module Federation manifest file must be a JSON. Please ensure the file at ${userPathToManifestFile} is a JSON.`);
        }
        pathToManifestFile = userPathToManifestFile;
    }
    (0, module_federation_1.validateDevRemotes)(options, workspaceProjects);
    const moduleFederationConfig = (0, module_federation_2.getModuleFederationConfig)(project.targets.build.options.tsConfig, context.workspaceRoot, project.root, 'angular');
    const remotes = (0, module_federation_2.getRemotes)(options.devRemotes, options.skipRemotes, moduleFederationConfig, {
        projectName: project.name,
        projectGraph,
        root: context.workspaceRoot,
    }, pathToManifestFile);
    let isCollectingStaticRemoteOutput = true;
    for (const app of remotes.staticRemotes) {
        const remoteProjectServeTarget = projectGraph.nodes[app].data.targets['serve-static'];
        const isUsingModuleFederationDevServerExecutor = remoteProjectServeTarget.executor.includes('module-federation-dev-server');
        let outWithErr = [];
        const staticProcess = (0, child_process_1.fork)(nxBin, [
            'run',
            `${app}:serve-static${context.target.configuration ? `:${context.target.configuration}` : ''}`,
            ...(isUsingModuleFederationDevServerExecutor
                ? [`--isInitialHost=false`]
                : []),
        ], {
            cwd: context.workspaceRoot,
            stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
        });
        staticProcess.stdout.on('data', (data) => {
            if (isCollectingStaticRemoteOutput) {
                outWithErr.push(data.toString());
            }
            else {
                outWithErr = null;
                staticProcess.stdout.removeAllListeners('data');
            }
        });
        staticProcess.stderr.on('data', (data) => devkit_1.logger.info(data.toString()));
        staticProcess.on('exit', (code) => {
            if (code !== 0) {
                devkit_1.logger.info(outWithErr.join(''));
                throw new Error(`Remote failed to start. See above for errors.`);
            }
        });
        process.on('SIGTERM', () => staticProcess.kill('SIGTERM'));
        process.on('exit', () => staticProcess.kill('SIGTERM'));
    }
    const devRemotes$ = [];
    for (const app of remotes.devRemotes) {
        if (!workspaceProjects[app].targets?.['serve']) {
            throw new Error(`Could not find "serve" target in "${app}" project.`);
        }
        else if (!workspaceProjects[app].targets?.['serve'].executor) {
            throw new Error(`Could not find executor for "serve" target in "${app}" project.`);
        }
        const runOptions = {};
        const [collection, executor] = workspaceProjects[app].targets['serve'].executor.split(':');
        const isUsingModuleFederationDevServerExecutor = executor.includes('module-federation-dev-server');
        const { schema } = (0, executor_utils_1.getExecutorInformation)(collection, executor, devkit_1.workspaceRoot);
        if ((options.verbose && schema.additionalProperties) ||
            'verbose' in schema.properties) {
            runOptions.verbose = options.verbose;
        }
        if (isUsingModuleFederationDevServerExecutor) {
            runOptions.isInitialHost = false;
        }
        const serve$ = (0, ngcli_adapter_1.scheduleTarget)(context.workspaceRoot, {
            project: app,
            target: 'serve',
            configuration: context.target.configuration,
            runOptions,
        }, options.verbose).then((obs) => {
            obs.toPromise().catch((err) => {
                throw new Error(`Remote '${app}' failed to serve correctly due to the following: \r\n${err.toString()}`);
            });
        });
        devRemotes$.push(serve$);
    }
    return devRemotes$.length > 0
        ? (0, rxjs_1.combineLatest)([...devRemotes$]).pipe((0, rxjs_1.concatMap)(() => currExecutor))
        : currExecutor;
}
exports.executeModuleFederationDevServerBuilder = executeModuleFederationDevServerBuilder;
exports.default = require('@angular-devkit/architect').createBuilder(executeModuleFederationDevServerBuilder);
